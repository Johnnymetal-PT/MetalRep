from odoo import models, api, _, fields
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)

class StockRule(models.Model):
    _inherit = 'stock.rule'

    @api.model
    def _run_pull(self, procurements):
        for procurement, rule in procurements:
            warehouse = rule.warehouse_id
            product = procurement.product_id
            demand_qty_total = procurement.product_qty

            _logger.info(f"[MTO LOGIC] üîÑ Starting _run_pull for product '{product.display_name}' (ID {product.id}), Qty: {demand_qty_total}")
            _logger.info(f"[MTO LOGIC] üéØ Target Warehouse: {warehouse.name} ({warehouse.code})")

            # Step 1: Use free stock in the target warehouse
            used_qty = 0.0
            free_qty_local = product.with_context(warehouse=warehouse.id).free_qty
            _logger.info(f"[MTO LOGIC] üè™ Free (unreserved) stock in target warehouse '{warehouse.code}': {free_qty_local}")
            if free_qty_local > 0:
                used_qty = min(free_qty_local, demand_qty_total)
                _logger.info(f"[MTO LOGIC] ‚úÖ Using {used_qty} from local free stock. Remaining needed: {demand_qty_total - used_qty}")

            # Step 2: Transfer from other warehouses
            wh_priority_map = {
                'BRA': ['FRE', 'SEI'],
                'SEI': ['FRE', 'BRA'],
                'FRE': ['BRA', 'SEI'],
            }
            wh_code = warehouse.code
            priorities = wh_priority_map.get(wh_code, [])
            _logger.info(f"[MTO LOGIC] üß≠ Priority fallback list for WH '{wh_code}': {priorities}")

            total_transferred = 0.0
            for alt_code in priorities:
                alt_wh = self.env['stock.warehouse'].search([('code', '=', alt_code)], limit=1)
                if not alt_wh:
                    _logger.warning(f"[MTO LOGIC] ‚ö†Ô∏è Alternate warehouse '{alt_code}' not found. Skipping.")
                    continue

                alt_free_stock = product.with_context(warehouse=alt_wh.id).free_qty
                _logger.info(f"[MTO LOGIC] üì¶ Free (unreserved) stock in '{alt_code}': {alt_free_stock}")

                if alt_free_stock <= 0:
                    _logger.info(f"[MTO LOGIC] ‚õî No available stock in '{alt_code}'. Skipping.")
                    continue

                transfer_qty = min(alt_free_stock, demand_qty_total - used_qty - total_transferred)
                if transfer_qty <= 0:
                    continue

                _logger.info(f"[MTO LOGIC] üöö Creating internal transfer of {transfer_qty} from {alt_code} ‚û°Ô∏è {wh_code}")

                picking_type = self.env['stock.picking.type'].search([
                    ('code', '=', 'internal'),
                    ('warehouse_id', '=', alt_wh.id)
                ], limit=1)

                if not picking_type:
                    raise UserError(_(f"No internal transfer type found for warehouse '{alt_wh.name}'"))

                sale_order = self.env['sale.order'].search([('name', '=', procurement.origin)], limit=1)
                group_id = procurement.values.get('group_id')

                picking = self.env['stock.picking'].create({
                    'picking_type_id': picking_type.id,
                    'location_id': alt_wh.lot_stock_id.id,
                    'location_dest_id': warehouse.lot_stock_id.id,
                    'origin': procurement.origin or _('Sales Order'),
                    'sale_id': sale_order.id if sale_order else False,
                    'partner_id': sale_order.partner_id.id if sale_order else False,
                    'group_id': group_id.id if group_id else False,
                    'company_id': procurement.company_id.id,
                    'move_ids_without_package': [(0, 0, {
                        'name': procurement.name,
                        'product_id': product.id,
                        'product_uom_qty': transfer_qty,
                        'product_uom': product.uom_id.id,
                        'location_id': alt_wh.lot_stock_id.id,
                        'location_dest_id': warehouse.lot_stock_id.id,
                        'description_picking': procurement.name,
                        'group_id': group_id.id if group_id else False,
                        'company_id': procurement.company_id.id,
                    })]
                })

                picking.message_post(body=_("Generated by dynamic MTO logic."))
                _logger.info(f"[MTO LOGIC] ‚úÖ Internal transfer created: Picking ID {picking.id}, From: {alt_code}, Qty: {transfer_qty}")

                total_transferred += transfer_qty
                if used_qty + total_transferred >= demand_qty_total:
                    break

            # Step 3: Trigger PO fallback if needed
            remaining_qty = demand_qty_total - used_qty - total_transferred
            if remaining_qty > 0.00001:
                _logger.info(f"[MTO LOGIC] üìâ {remaining_qty} still unfulfilled. Triggering PO fallback.")
                try:
                    new_values = dict(procurement.values or {})
                    new_values.update({
                        'warehouse_id': warehouse.id,
                        'route_ids': procurement.values.get('route_ids'),
                        'group_id': procurement.values.get('group_id'),
                        'rule_id': rule.id,
                    })

                    fallback_procurement = type(procurement)(
                        product_id=procurement.product_id,
                        product_qty=remaining_qty,  # ‚úÖ FIXED
                        product_uom=procurement.product_uom,
                        location_id=procurement.location_id,
                        name=procurement.name,
                        origin=procurement.origin,
                        company_id=procurement.company_id,
                        values=new_values,
                    )

                    _logger.info(f"[MTO LOGIC] üöÄ Calling super()._run_pull with Procurement-like object:")
                    _logger.info(f"[MTO LOGIC]    Product: {product.display_name}")
                    _logger.info(f"[MTO LOGIC]    Qty: {remaining_qty}")
                    _logger.info(f"[MTO LOGIC]    Clean Values: {new_values}")

                    super(StockRule, self)._run_pull([(fallback_procurement, rule)])
                    _logger.info(f"[MTO LOGIC] ‚úÖ PO fallback successfully triggered.")
                except Exception as e:
                    _logger.exception(f"[MTO LOGIC] ‚ùå Final fallback error: {e}")
                    raise
            else:
                _logger.info(f"[MTO LOGIC] ‚úÖ Demand fully satisfied ‚Äî skipping PO fallback.")

            # Step 4: Delivery
            if procurement.values.get('group_id'):
                _logger.info(f"[MTO LOGIC] üîÅ Triggering delivery by reusing group_id {procurement.values['group_id'].id}")
                try:
                    delivery_values = dict(procurement.values or {})
                    mto_route = self.env.ref('stock.route_warehouse0_mto', raise_if_not_found=False)
                    if mto_route and 'route_ids' in delivery_values:
                        delivery_values['route_ids'] = [r for r in delivery_values['route_ids'] if r.id != mto_route.id]
                        _logger.info("[MTO LOGIC] üßπ Removed MTO route from delivery_values")

                    sale_line_id = procurement.values.get('sale_line_id')
                    demand_qty = 0.0
                    if sale_line_id:
                        sale_line = self.env['sale.order.line'].browse(sale_line_id)
                        if sale_line and sale_line.product_id == product:
                            demand_qty = sale_line.product_uom_qty
                            _logger.info(f"[MTO LOGIC] üì¶ Fetched sale.order.line demand qty: {demand_qty}")
                        else:
                            _logger.warning("[MTO LOGIC] ‚ö†Ô∏è Sale line found but product mismatch.")
                    else:
                        _logger.warning("[MTO LOGIC] ‚ö†Ô∏è No sale_line_id in procurement.values")

                    group = delivery_values.get('group_id')
                    delivery = self.env['stock.picking'].search([
                        ('group_id', '=', group.id if group else False),
                        ('picking_type_id.code', '=', 'outgoing'),
                        ('state', 'in', ['confirmed', 'waiting', 'assigned']),
                    ], order='id desc', limit=1)

                    patched = False
                    if delivery:
                        for move in delivery.move_ids.filtered(lambda m: m.product_id == product):
                            _logger.info(f"[MTO LOGIC] üõ†Ô∏è Existing delivery move found. Patching from {move.product_uom_qty} to {demand_qty}")
                            move.product_uom_qty = demand_qty
                            move._recompute_state()
                            patched = True

                    if not patched:
                        _logger.info(f"[MTO LOGIC] ‚ûï No existing move found. Creating new delivery move.")
                        delivery_proc = type(procurement)(
                            product_id=procurement.product_id,
                            #product_uom_qty=0.0,  # ‚úÖ FIXED
                            product_uom=procurement.product_uom,
                            location_id=procurement.location_id,
                            name=procurement.name,
                            origin=procurement.origin,
                            company_id=procurement.company_id,
                            values=delivery_values,
                        )
                        super(StockRule, self)._run_pull([(delivery_proc, rule)])
                        # Patch immediately
                        new_delivery = self.env['stock.picking'].search([
                            ('group_id', '=', group.id if group else False),
                            ('picking_type_id.code', '=', 'outgoing'),
                            ('state', 'in', ['confirmed', 'waiting', 'assigned']),
                        ], order='id desc', limit=1)
                        for move in new_delivery.move_ids.filtered(lambda m: m.product_id == product):
                            _logger.info(f"[MTO LOGIC] üßæ Creating new delivery move with qty: {demand_qty}")
                            move.product_uom_qty = demand_qty
                            move._recompute_state()

                except Exception as e:
                    _logger.warning(f"[MTO LOGIC] ‚ö†Ô∏è Attempted delivery run raised: {e}")

