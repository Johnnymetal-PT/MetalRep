import osimport reimport base64import loggingfrom PIL import Image, UnidentifiedImageErrorfrom io import BytesIOfrom odoo import models, fields, apifrom datetime import datetimeimport hashlibfrom psycopg2.errors import SerializationFailuretry:    import psutilexcept ImportError:    psutil = None    _logger = logging.getLogger(__name__)class ProductUpdate(models.Model):    _name = 'product.update'    _description = 'Product Update'    def upload_file(self, model, record_id, field_name, file_path):        try:            with open(file_path, 'rb') as file:                file_data = base64.encodebytes(file.read()).decode()            self.env[model].browse(record_id).write({field_name: file_data})        except Exception as e:            _logger.error(f"Error uploading file: {e} | {model} {record_id} {field_name} {file_path}")    def get_full_category_name(self, category):        if category.parent_id:            return self.get_full_category_name(category.parent_id) + '/' + category.name        else:            return category.name    def normalize_folder_name(self, folder_name):        return re.sub(r'^\d+\.', '', folder_name).strip()    def load_folder_tree(self, root_folder):        for root, dirs, _ in os.walk(root_folder):            for dir_name in dirs:                yield {                    'path': os.path.join(root, dir_name).replace("\\", "/"),                    'changed_path': os.path.join(root, self.normalize_folder_name(dir_name)).replace("\\", "/"),                }                    def find_category_folder(self, category_folder, folder_tree):        normalized_category_folder = category_folder        for folder in folder_tree:            if normalized_category_folder in folder['changed_path']:                return folder['path']        return None    def create_or_get_category(self, name, parent_id=None, img_path=None):        category = self.env['product.category'].search([('name', '=', name), ('parent_id', '=', parent_id)], limit=1)        if not category:            category = self.env['product.category'].create({'name': name, 'parent_id': parent_id})            if parent_id:                parent_category = self.env['product.category'].browse(parent_id)                if parent_category.name.upper() == "ALL" and img_path:                    # Upload images if path is provided                    image_files = [f for f in os.listdir(img_path) if os.path.isfile(os.path.join(img_path, f))]                    image_files.sort()  # Sort to ensure consistent order                    vals = {}                    if len(image_files) > 0:                        with open(os.path.join(img_path, image_files[0]), 'rb') as image_file:                            vals['cat_image_1'] = base64.b64encode(image_file.read())                    if len(image_files) > 1:                        with open(os.path.join(img_path, image_files[1]), 'rb') as image_file:                            vals['cat_image_2'] = base64.b64encode(image_file.read())                    if vals:                        category.write(vals)        return category    def create_or_get_web_category(self, category_name, parent_id=None):        web_category = self.env['product.public.category'].search([('name', '=', category_name), ('parent_id', '=', parent_id)], limit=1)        if not web_category:            web_category = self.env['product.public.category'].create({'name': category_name, 'parent_id': parent_id})        return web_category    #(disabled)    #@api.model    #def add_categoria_attribute_to_product(self, product_id, variant_name):    #    contains_variant_info = any(    #        keyword.upper() in variant_name.upper() for keyword in ['3D', 'FICHA', 'CERTIFICADO'])    #    #    if not contains_variant_info:    #        # Fetch the product template    #        product_template = self.env['product.template'].browse(product_id)    #    #        if not product_template.exists():    #            _logger.info(f'Product template with ID {product_id} does not exist')    #            return    #    #        # Search for the existing attribute values    #        attribute_value = self.env['product.attribute.value'].search([('name', '=', variant_name)], limit=1)    #    #        # Skip if the attribute value does not exist    #        if not attribute_value:    #            _logger.info(f'Attribute value {variant_name} does not exist')    #            return    #    #       categoria_attribute = attribute_value.attribute_id    #    #        # Check if the attribute line already exists for the product    #        attribute_line = self.env['product.template.attribute.line'].search([    #            ('product_tmpl_id', '=', product_template.id),    #            ('attribute_id', '=', categoria_attribute.id)    #        ], limit=1)    #    #        if not attribute_line:    #            # Create the attribute line and add it to the product template    #            attribute_line = self.env['product.template.attribute.line'].create({    #                'product_tmpl_id': product_template.id,    #                'attribute_id': categoria_attribute.id,    #                'value_ids': [(6, 0, [attribute_value.id])]    #            })    #        else:    #            # Add the variant value to the existing attribute line if it's not already added    #            if attribute_value.id not in attribute_line.value_ids.ids:    #                attribute_line.write({    #                    'value_ids': [(4, attribute_value.id)]    #                })    #    #        return product_template    #    #    return None    # --- Variant support (currently disabled)    # def get_variants_from_path(self, path):    #     """    #     Helper method to extract variant names from the relative image path.    #     Assumes that each folder level represents an attribute value.    #     """    #     parts = path.split(os.sep)    #     if len(parts) > 1:    #         return parts[:-1]  # Exclude the file name part    #     return []    # --- Variant support (currently disabled)    # def get_variants_by_attributes(self, product_template_id, variant_names):    #     domain = [('product_tmpl_id', '=', product_template_id)]    #     for variant_name in variant_names:    #         domain.append(('product_template_attribute_value_ids.name', '=', variant_name))    #     return self.env['product.product'].search(domain)    def resize_image(self, image_data, max_width=1920, max_height=1920):        """        Resize an image to fit within a maximum width and height.        """        image = Image.open(BytesIO(image_data))        image.thumbnail((max_width, max_height), Image.ANTIALIAS)        output = BytesIO()                # Convert RGBA to RGB before saving as JPEG        if image.mode == 'RGBA':            image = image.convert('RGB')                    image.save(output, format='JPEG')        return output.getvalue()    def upload_images(self, folder_path, product, is_main_product=True, variant_names=None):        """Uploads images for a product or its variants."""        variant_names = variant_names or []        processed_images = set()        main_image_uploaded = False        _logger.info(f"Uploading images from folder: {folder_path} for {'main product' if is_main_product else 'variant'}")        for root, _, files in os.walk(folder_path):            for file in sorted(files):                if file.lower() == 'thumbs.db':                    continue                image_path = os.path.join(root, file)                try:                    with open(image_path, 'rb') as image_file:                        image_data = image_file.read()                    if len(image_data) > 50_000_000:                        image_data = self.resize_image(image_data)                    image_hash = hashlib.sha256(image_data).hexdigest()                    if image_hash in processed_images:                        _logger.info(f"Skipping duplicate image: {image_path}")                        continue                    processed_images.add(image_hash)                    image_encoded = base64.b64encode(image_data)                    if is_main_product and 'IMAGENS' in root.upper() and not variant_names:                        if not main_image_uploaded:                            product.write({'image_1920': image_encoded})                            main_image_uploaded = True                            _logger.info(f"Set first image as thumbnail: {file}")                        else:                            self.env['product.image'].create({                                'product_tmpl_id': product.id,                                'name': file,                                'image_1920': image_encoded,                                'sequence': 10,                            })                            _logger.info(f"Added extra media: {file}")                    # --- Variant support (currently disabled)                    # else:                    #     variants = self.get_variants_by_attributes(product.id, variant_names)                    #     if variants:                    #         for variant in variants:                    #             self.env['product.image'].create({                    #                 'product_variant_id': variant.id,                    #                 'name': file,                    #                 'image_1920': image_encoded,                    #             })                    #             _logger.info(f"Added image to variant: {variant.name}")                    #     else:                    #         _logger.warning(f"No matching variants found for image: {image_path}")                except UnidentifiedImageError as e:                    _logger.warning(f"UnidentifiedImageError for file {image_path}: {e}")                except Exception as e:                    _logger.error(f"Error processing image {image_path}: {e}")    def process_multi_variant_product(self, category_id, web_category_id, pos_category_id, product_path):        """        Process folders where each subfolder with a default_code is an independent product.template,        and shared folders (IMAGENS, 3D, FICHA TECNICA, CERTIFICADO CONFORMIDADE) may exist.        """        shared_folders = {}        variant_folders = []        for entry in os.listdir(product_path):            full_path = os.path.join(product_path, entry)            if not os.path.isdir(full_path):                continue            normalized_name = self.normalize_folder_name(entry)            if normalized_name.upper() in ['IMAGENS', '3D', 'FICHA TECNICA', 'CERTIFICADO CONFORMIDADE']:                shared_folders[normalized_name.upper()] = full_path            else:                variant_folders.append((normalized_name, full_path))        for default_code, folder_path in variant_folders:            # Reuse parent folder name as product name            product_name = os.path.basename(product_path)            # Search or create product            product = self.env['product.template'].search([('default_code', '=', default_code)], limit=1)            if not product:                product = self.env['product.template'].create({                    'name': product_name,                    'default_code': default_code,                    'categ_id': category_id,                    'public_categ_ids': [(4, web_category_id)],                    'pos_categ_ids': [(4, pos_category_id)] if pos_category_id else [],                    'is_published': True,                })            try:                # Clean existing media                self._clear_product_media(product)                # Process images                imagens_folder = self._get_specific_or_shared_folder(folder_path, 'IMAGENS', shared_folders)                if imagens_folder:                    self.upload_images(imagens_folder, product, is_main_product=True)                # Process documentation (3D, FICHA TECNICA, etc.)                self._process_additional_docs(product, folder_path, shared_folders, product_path)            except Exception as e:                _logger.error(f"Error processing product {default_code}: {e}")    def _clear_product_media(self, product):        self.env['ir.attachment'].search([            ('res_model', '=', 'product.template'), ('res_id', '=', product.id)        ]).unlink()        self.env['product.image'].search([            ('product_tmpl_id', '=', product.id)        ]).unlink()    def _get_specific_or_shared_folder(self, variant_folder, folder_name, shared_folders):        specific = os.path.join(variant_folder, folder_name)        return specific if os.path.isdir(specific) else shared_folders.get(folder_name.upper())    def create_or_get_category(self, name, parent_id=None, img_path=None):        category = self.env['product.category'].search([            ('name', '=', name),            ('parent_id', '=', parent_id)        ], limit=1)        if not category:            category = self.env['product.category'].create({                'name': name,                'parent_id': parent_id            })        # If image path is provided and category folder contains image files, upload them        if img_path and os.path.isdir(img_path):            image_files = [                f for f in os.listdir(img_path)                if os.path.isfile(os.path.join(img_path, f))            ]            image_files.sort()  # Ensure consistent ordering            vals = {}            if len(image_files) > 0:                with open(os.path.join(img_path, image_files[0]), 'rb') as image_file:                    vals['cat_image_1'] = base64.b64encode(image_file.read())            if len(image_files) > 1:                with open(os.path.join(img_path, image_files[1]), 'rb') as image_file:                    vals['cat_image_2'] = base64.b64encode(image_file.read())            if vals:                category.write(vals)                _logger.info(f"Uploaded category images for: {name}")        return category    def _process_additional_docs(self, product, variant_path, shared_folders, base_path):        for doc_type in ['3D', 'FICHA TECNICA', 'CERTIFICADO CONFORMIDADE']:            folder = self._get_specific_or_shared_folder(variant_path, doc_type, shared_folders)            if not folder:                continue            for file in os.listdir(folder):                if file.lower() == 'thumbs.db':                    continue                file_path = os.path.join(folder, file)                if not os.path.isfile(file_path):                    continue                try:                    attachment_name = f"{doc_type} » {file}"                    with open(file_path, 'rb') as f:                        file_data = base64.b64encode(f.read())                    self.env['product.document'].create({                        'name': attachment_name,                        'datas': file_data,                        'res_id': product.id,                        'res_model': 'product.template',                        'active': True,                        'shown_on_product_page': True,                    })                except Exception as e:                    _logger.error(f"Error attaching document {file} for product {product.name}: {e}")    def process_additional_content(self, product, product_path):        for folder, _, files in os.walk(product_path):            for file in files:                if 'IMAGENS' in folder.upper() or file.lower() == 'thumbs.db':                    continue                try:                    attachment_path = os.path.join(folder, file)                    attachment_name = os.path.relpath(attachment_path, product_path).replace(os.sep, ' » ')                    with open(attachment_path, 'rb') as f:                        file_data = base64.b64encode(f.read())                    self.env['product.document'].create({                        'name': attachment_name,                        'datas': file_data,                        'res_id': product.id,                        'res_model': 'product.template',                        'active': True,                        'shown_on_product_page': True,                    })                except Exception as e:                    _logger.error(f"Error processing additional content for {product.name}: {e}")    def process_complementos_folder(self, complementos_folder, category_id):        """        Processes the COMPLEMENTOS folder, updating the corresponding products        with images and linking them as accessories to the main product.        """        main_product_name = os.path.basename(os.path.dirname(complementos_folder))        main_product_name_normalized = self.normalize_folder_name(main_product_name)        main_product = self.env['product.template'].search([('name', '=', main_product_name_normalized)], limit=1)        if not main_product:            _logger.info(f'Main product not found for COMPLEMENTOS folder: {complementos_folder}')            return        for folder_name in os.listdir(complementos_folder):            product_path = os.path.join(complementos_folder, folder_name)            if os.path.isdir(product_path):                product_name = self.normalize_folder_name(folder_name)                _logger.info(f'Processing COMPLEMENTOS product: {product_name.upper()}')                product_template = self.env['product.template'].search([('name', '=', product_name)], limit=1)                if not product_template:                    _logger.info(f'COMPLEMENTOS product not found: {product_name}')                    continue                # Clear existing images for the product                attachments = self.env['ir.attachment'].search([                    ('res_model', '=', 'product.template'),                    ('res_id', '=', product_template.id),                ])                attachments.unlink()                product_images = self.env['product.image'].search([('product_tmpl_id', '=', product_template.id)])                product_images.unlink()                # Remove images from variants                for variant in product_template.product_variant_ids:                    variant_images = self.env['product.image'].search([('product_variant_id', '=', variant.id)])                    variant_images.unlink()                # Process images within the COMPLEMENTOS product                self.process_complementos_images(product_template, product_path)                # Link the COMPLEMENTOS product variants to the main product as accessories                for variant in product_template.product_variant_ids:                    main_product.write({'accessory_product_ids': [(4, variant.id)]})    def upload_top_level_category_images(self, root_folder, parent_category):        """        Upload category images only from the first-level folders inside root_folder.        """        for folder_name in os.listdir(root_folder):            folder_path = os.path.join(root_folder, folder_name)            if not os.path.isdir(folder_path):                continue            normalized_name = self.normalize_folder_name(folder_name)            # Upload images only if this category folder contains image files            image_files = [                f for f in os.listdir(folder_path)                if os.path.isfile(os.path.join(folder_path, f))                and f.lower().endswith(('.jpg', '.jpeg', '.png'))            ]            if image_files:                category = self.create_or_get_category(normalized_name, parent_category.id, folder_path)                _logger.info(f"Top-level category image(s) uploaded for: {normalized_name}")    def process_complementos_images(self, product_template, product_path):        try:            for folder_name in os.listdir(product_path):                normalized_folder_name = self.normalize_folder_name(folder_name)                if normalized_folder_name.upper() == 'IMAGENS':                    images_folder = os.path.join(product_path, folder_name)                    self.upload_images(images_folder, product_template, is_main_product=True)                    for variant_folder in os.listdir(images_folder):                        variant_folder_path = os.path.join(images_folder, variant_folder)                        if os.path.isdir(variant_folder_path):                            variant_name = self.normalize_folder_name(variant_folder)                            # --- Variant support (currently disabled)                            # self.add_categoria_attribute_to_product(product_template.id, variant_name)                            # variants = self.get_variants_by_attributes(product_template.id, [variant_name])                            # if variants:                            #     for variant in variants:                            #         _logger.info(f"Uploading images to variant: {variant.name}")                            #         self.upload_images(variant_folder_path, variant, is_main_product=False, variant_names=[variant_name])                            # else:                            #     _logger.info(f"No matching variants found for: {variant_name}.")                            #     attribute_values = self.env['product.attribute.value'].search([('name', '=', variant_name)])                            #     if not attribute_values:                            #         _logger.warning(f"Attribute value {variant_name} not found in the database.")                            #     else:                            #         _logger.warning(f"Attribute value {variant_name} found, but no matching variant.")        except Exception as e:            _logger.error(f"Error processing COMPLEMENTOS images: {e}")            self.env.cr.rollback()    @api.model    def update_products(self):        """Main method to update products with retry logic and email notifications."""        retry_count = 5        for attempt in range(retry_count):            try:                #root_folder = r"/ProgGest/Odoo/1.Produtos"                root_folder = r"/mnt/partilha_geral/PRODUTOS"                all_category = self.create_or_get_category('All', None)                # Upload images for top-level categories under 1.Produtos                self.upload_top_level_category_images(root_folder, all_category)                all_web_category = self.create_or_get_web_category('Todas')                if not os.path.exists(root_folder):                    _logger.error(f"Root folder does not exist: {root_folder}")                    return  # No email needed since the process didn't run                self.log_memory_usage("Start of update_products")                self.process_folders_iteratively(root_folder, all_category, all_web_category)                self.log_memory_usage("End of update_products")                _logger.info(f"Product update completed at {datetime.now()}")                self.send_email_notification()  # Send email on success                break  # Exit loop if successful            except SerializationFailure as e:                if attempt < retry_count - 1:                    _logger.warning(f"Serialization failure on attempt {attempt + 1}. Retrying...")                else:                    _logger.error(f"Maximum retries reached: {str(e)}")                    raise e  # Let the exception propagate after all retries    def send_email_notification(self):        """Send email using template ID 79."""        try:            template = self.env['mail.template'].browse(79)  # Fetch by numeric ID            if template and template.exists():                template.send_mail(self.id, force_send=True)                _logger.info("Email sent successfully using template ID 79.")            else:                _logger.error("Email template with ID 79 not found.")        except Exception as e:            _logger.error(f"Error sending email notification: {e}")    def find_product_info_from_imagens(self, start_path):        """        Traverse from a found IMAGENS folder up the tree to find:        - Product name (folder containing IMAGENS)        - Subcategories and categories (all folders above, stopping at 'PRODUTOS')        - Ignores numerical prefixes like '103.' in folder names        - Returns the product folder path relative to the 'PRODUTOS' root        """        current_path = os.path.abspath(start_path)        components = []        folder_paths = []        while True:            current_path, folder = os.path.split(current_path)            normalized_name = self.normalize_folder_name(folder)            if normalized_name.upper() == 'PRODUTOS':                break            components.insert(0, normalized_name)            folder_paths.insert(0, os.path.join(current_path, folder))        if not components or components[-1].upper() == 'IMAGENS':            components = components[:-1]            folder_paths = folder_paths[:-1]        if len(components) < 1:            return None, [], None        product_name = components[-1]        subcategories = components[:-1]        product_path = folder_paths[-1]        return product_name, subcategories, product_path    def process_folders_iteratively(self, root_folder, parent_category, web_category):        """Updated to derive product name and hierarchy from IMAGENS folder."""        for root, dirs, _ in os.walk(root_folder):            for dir_name in dirs:                if self.normalize_folder_name(dir_name).upper() == 'IMAGENS':                    imagens_path = os.path.join(root, dir_name)                    # Extract info from folder hierarchy                    product_name, hierarchy, base_path = self.find_product_info_from_imagens(imagens_path)                    if not product_name:                        continue                    _logger.info(f"Derived product name: {product_name} from folder: {imagens_path}")                    # Build categories from hierarchy                    current_parent_id = parent_category.id                    current_web_parent_id = web_category.id                    for i, level_name in enumerate(hierarchy):                        level_path = os.path.join(root_folder, *hierarchy[:i+1])                        current_parent = self.create_or_get_category(level_name, current_parent_id, img_path=level_path)                        current_web = self.create_or_get_web_category(level_name, current_web_parent_id)                        current_parent_id = current_parent.id                        current_web_parent_id = current_web.id                    pos_category = self.env['pos.category'].search([                        ('name', '=', product_name)                    ], limit=1)                    if not pos_category:                        pos_category = self.env['pos.category'].create({'name': product_name})                    # Process products inside product folder                    self.process_multi_variant_product(                        current_parent_id,                        current_web_parent_id,                        pos_category.id,                        base_path  # the folder that contains the default_code folders                    )                    # Handle COMPLEMENTOS if exists                    complementos_folder = self.find_complementos_folder(base_path)                    if complementos_folder:                        _logger.info(f"Processing COMPLEMENTOS folder: {complementos_folder}")                        self.process_complementos_folder(complementos_folder, current_parent_id)                    break  # only use the first IMAGENS in this path    def find_images_folder(self, folder_path):        """Find the IMAGENS folder within a given path."""        return next(            (os.path.join(folder_path, f) for f in os.listdir(folder_path)             if os.path.isdir(os.path.join(folder_path, f)) and 'IMAGENS' in f.upper()),            None        )    def find_complementos_folder(self, folder_path):        """Find the COMPLEMENTOS folder within a given path."""        return next(            (os.path.join(folder_path, f) for f in os.listdir(folder_path)             if os.path.isdir(os.path.join(folder_path, f)) and 'COMPLEMENTOS' in f.upper()),            None        )    def log_memory_usage(self, message=""):        if psutil:            process = psutil.Process(os.getpid())            memory_usage = process.memory_info().rss / (1024 ** 2)  # Convert bytes to MB            _logger.info(f"[Memory Usage] {message}: {memory_usage:.2f} MB")        else:            _logger.warning("psutil is not installed; skipping memory logging.")          class ProductTemplate(models.Model):    _inherit = 'product.template'    def update_product_data(self):        self.env['product.update'].update_products()class ProductAttribute(models.Model):    _inherit = 'product.attribute'class ProductAttributeValue(models.Model):    _inherit = 'product.attribute.value'